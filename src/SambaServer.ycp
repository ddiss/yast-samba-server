/**
 * File:	modules/Samba-server.ycp
 * Package:	Configuration of samba-server
 * Summary:	Data for configuration of samba-server, input and output functions.
 * Authors:	Stanislav Visnovsky <visnov@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of samba-server.
 * Input and output routines.
 */

{

module "SambaServer";
textdomain "samba-server";

import "Samba";
import "SambaServerPassdb";
import "SambaSecrets";

import "Ldap";
import "Progress";
import "Report";
import "Service";
import "URL";

include "samba-server/routines.ycp";
include "samba-client/routines.ycp";

global define symbol DetermineRole();
global define void ReadLDAPSettings();
global define boolean WriteSettings();
global define void WriteLDAPSettings();
global define boolean enableServer( boolean on );
global define string roleName( symbol role );
global define boolean ReloadSettings();
global define void disableAllPrinters();
global define boolean enableShare( string name, boolean on );
global define void enableAllSystemPrinters();
global boolean EstablishTrustedDomain (string domain, string password);
boolean EnsureRootAccount ();

/**
 * list of required packages
 */
global list<string> required_packages = (list<string>)union (["samba"], Samba::required_packages);

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = nil;

/**
 * Abort function
 * @return blah blah lahjk
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
	return AbortFunction();
    return false;
}

/**
 * Data was modified?
 */
global boolean modified = false;

global boolean proposal_valid = false;

global boolean globals_configured = false;
global boolean shares_configured = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

global boolean ServerReallyAbort () {
    return !(modified || Samba::modified || SambaServerPassdb::Modified ()) || Popup::ReallyAbort (true);
}

/** ================================ global data =============================*/

/**
 * role of the server: `standalone, `bdc, `pdc
 */
global symbol role = `standalone;

/**
 * Is service enabled? 
 */
boolean service = false;

/**
 * domain master
 */
global string domain_master = "auto";

/**
 * preferred master
 */
global string preferred_master = "auto";

/**
 * add machine script
 */
global string add_machine_script = "";

/**
 * Should be [homes] section present
 */
global boolean share_homes = false;

/**
 * Should be [printers] section present
 */
global boolean share_printers = false;

/**
 * load printers
 */
global boolean load_printers = true;

/**
 * LDAP admin dn
 */
global string LDAP_admin_dn = nil;

/**
 * LDAP suffix
 */
global string LDAP_suffix = nil;

/**
 * all shares
 */
global map<string, map<string,any> > shares = $[];

/**
 * status of all available printers
 */
global map<string, boolean> printer_status = $[];

/**
 * mapping of name to role
 */
global map<symbol, string> role2name = $[
    `disabled: "Disabled",
    `standalone: "File and printer sharing",
    `bdc: "Backup Domain Controller",
    `pdc: "Primary Domain Controller"
];

/**
 * mapping of role2name
 */
global map<string, symbol> name2role = $[
    "Disabled" : `disabled,
    "File and printer sharing" : `standalone,
    "Backup Domain Controller" : `bdc,
    "Primary Domain Controller" : `pdc
];

global string netbios_name = "";

global map<string,any> global_config = $[];

global map<string,boolean> trusted_domains = $[];
global map<string,string> trusted_domains_password = $[];

/** ============================= end of global data ==========================*/

/**
 * list of shares to be removed
 */
map<string, map<string,any> > removed_shares  = $[];

/**
 * list of all system printers
 */
list<string> system_printers = [];

/**
 * Just ensure a translation do exist
 */
// translators: server role name
string ____1 = _("File and Printer Sharing");
// translators: server role name
string ____2 =_("Backup Domain Controller");
// translators: server role name
string ____3 =_("Primary Domain Controller");

/** ============================= defaults ====================================*/

/**
 * default settings for [printers]
 */
map<string, any> default_printers = $[
   "comment": "All Printers",
   "path": "/var/tmp",
   "printable": true,
   "browseable": false,
   "available": "yes",
   "guest ok": "no",
   "yast": true
];

/**
 * default settings for a single printer share
 */
map<string, any> default_printer_share = $[
   "path": "/var/tmp",
   "browseable": true,
   "printable": true,
   "yast": true
];

/**
 * default settings for [homes]
 */
map<string, any> default_homes = $[
    "comment": "Home Directories",
    "valid users": "%S",
    "browseable" : false,
    "read only": "no",
    "guest ok" : false,
    "printable" : false
];

/** ============================= end of defaults =============================*/

map<string,boolean> GetTrustedDomains () {
    map <string, string> secrets = SambaSecrets::Read ();
    
    if (secrets == nil )
    {
	y2warning ("Cannot get the list of trusted domains");
	Report::Error ( _("Cannot read the list of trusted domains.") );

	trusted_domains = $[];
	return $[];
    }
    
    map <string, boolean> res = $[];
    
    foreach (string key, string data, secrets,``{
	if ( regexpmatch ( key, "SECRETS/\\$DOMTRUST.ACC/.+" ) )
	{
	    string domain = regexpsub (key, "SECRETS/\\$DOMTRUST.ACC/(.+)", "\\1");
	    res [domain] = true;
	}
    });
    
    trusted_domains = res;
    return res;
}

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

void InstallSchema () {
    import "NetworkDevices";
    import "Hostname";
    import "DNS";
    import "LdapServerAccess";
    
    // check, if the local server is used
    boolean local_server = false;
    
    list<string> backends = SambaServerPassdb::GetBackends ();
    foreach (string backend, backends, ``{
	string details = SambaServerPassdb::BackendDetails (backend);
	string type = SambaServerPassdb::BackendSAM (backend);
	if (type == "ldap" || type == "ldapsam")
	{	    
	    map url = URL::Parse (details);
	    string host = url["host"]:"";
	    if ( host == "127.0.0.1" 
		|| host == "localhost" 
		|| host == DNS::hostname 
		|| host == Hostname::MergeFQ(DNS::hostname, DNS::domain)
		|| size(NetworkDevices::Locate ("IPADDR", host))>0
	    )
	    {
		local_server = true;
		break;
	    }
	}
    });
    

    if (local_server) {
	boolean restart_server = false;

        y2milestone ("LDAP server is local, including the Samba3 schema");
	
	// add schema
	boolean ret = LdapServerAccess::AddLdapSchemas(["/etc/openldap/schema/samba3.schema"], false);
	if (ret == true) {
	    restart_server = true;
	} else if (ret == nil) {
            y2error("Add LDAP Samba3 schema failed");
        }
	
	// add indices
	foreach(string attr, [ "sambaSID", "sambaPrimaryGroupSID", "sambaDomainName"], {
	    ret = LdapServerAccess::AddIndex($["attr":attr, "param":"eq"], LDAP_suffix, false);
	    if (ret == true) {
		restart_server = true;
	    } else if (ret == nil) {
                y2error("Add Index '%1' failed", attr);
	    }
	});

        // setup ACLs
	if (LDAP_admin_dn != nil && size(LDAP_admin_dn) > 0) {
	    ret = LdapServerAccess::AddSambaACLHack(LDAP_admin_dn, false);
	    if (ret == true) {
		restart_server = true;
	    } else if (ret == nil) {
        	y2error("Samba ACL Hack failed");
    	    }
	}

	if (restart_server) {
	    // restart server if running
	    if (Service::Status("ldap") == 0) {
    		Service::Restart("ldap");
	    }
	}
    } else {
        y2milestone ("LDAP server is remote, not checking if schemas are properly included");
    }
}

boolean  UsingCommonLDAP () {
    // check the default passdb backend
    string backend = select( SambaServerPassdb::GetBackends (), 0, "" );
    
    if (backend == "")
    {
	y2milestone ("Not using common LDAP: no default backend");
	return false;
    }
    
    string tmp = SambaServerPassdb::BackendSAM (backend);

    // is it LDAP?
    if ( tmp != "ldap" && tmp != "ldapsam" )
    {
	y2milestone ("Not using common LDAP: default not LDAP");
	return false;
    }
    
    tmp = SambaServerPassdb::BackendDetails (backend);
    map url = URL::Parse (tmp);
    
    if (Ldap::server != url["host"]:nil)
    {
	y2milestone ("Not using common LDAP: different server (%1 vs %2)", Ldap::server, url["host"]:nil);
	return false;
    }
    
    boolean ret = Ldap::GetDomain () == LDAP_suffix;
    
    y2milestone ("Suffixes are same: %1", ret);
    return ret;
}

/**
 * Read all samba-server settings
 * @return true on success
 */
global define boolean Read() ``{

    /* Samba-server read dialog caption */
    string caption = _("Initializing Samba Server Configuration");

    
    integer steps = 4;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    // translators: progress stage 1/4
	    _("Read global Samba settings"),
	    // translators: progress stage 2/4
	    _("Read the Samba shares"),
	    // translators: progress stage 3/4
	    _("Read the printing settings"),
	    // translators: progress stage 4/4
	    _("Read the LDAP settings"),
	], [
	    // translators: progress step 1/4
	    _("Reading global Samba settings..."),
	    // translators: progress step 2/4
	    _("Reading the Samba shares..."),
	    // translators: progress step 3/4
	    _("Reading the printing settings..."),
	    // translators: progress step 4/4
	    _("Reading the LDAP settings..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // read global settings
    Progress::NextStage();

    Progress::off ();
    Samba::Read();
    Progress::on ();
    
    string value = "";
    
    SambaServerPassdb::Read ();
    
    // read the complete global section
    list<string> options = (list<string>)SCR::Dir( .etc.smb.value.global );
    foreach( string option, options, ``{
	global_config[option] = SCR::Read( add(.etc.smb.value.global, option) );
    });
    
    // fix the value of some options
    global_config["domain logons"] = normalize_boolean ( global_config ["domain logons"]:"no", false );
    global_config["local master"] = normalize_boolean ( global_config ["local master"]:"yes", true );

    // read some settings in a special way    
    value = (string) SCR::Read( .etc.smb.value.global."add machine script" );
    if( value != nil ) add_machine_script = value;
    value = (string) SCR::Read( .etc.smb.value.global."domain master" );
    if( value != nil ) domain_master = value;
    value = (string) SCR::Read( .etc.smb.value.global."netbios name" );
    if( value != nil ) netbios_name = value;
    // synonym: "prefered master"
    value = (string) SCR::Read( .etc.smb.value.global."preferred master" );
    if( value != nil ) preferred_master = value;
    value = (string) SCR::Read( .etc.smb.value.global."prefered master" );
    if( value != nil && value != preferred_master ) {
	// translators: error popup on conflicting options, %1 is the name of the
	// option which will be used, %2 is its value, %3 is the name of the
	// other option, %4 is the %3's value
	Report::Warning( sformat( _("The configuration file contains conflicting
options:

%1: %2
%3: %4

YaST2 will use the value of '%1' for now.

Remove one of the options to resolve this conflict.
"), "preferred master", 
	preferred_master, "prefered master", value ) );
    }

    service = Service::Enabled( "smb" );

    role = DetermineRole();
    
    y2milestone( "Service: %1", service );
    y2milestone( "Found role: %1", role );
    
    // get trusted domains
    GetTrustedDomains ();

    globals_configured = true;
    
    // read shares settings
    Progress::NextStage();

    // read the list of shares, skip "global" section        
    list<string> sl = (list<string>)SCR::Dir( .etc.smb.section );
    sl = filter(string s, sl, ``(s != "global" ) );
    
    shares = (map<string, map<string,any> >)listmap( string share, sl, ``{
	path p = add( .etc.smb.value, share );
	
	map result = $[];
	list<string> options = (list<string>)SCR::Dir( p );
	foreach( string option, options, ``{
	    result[option] = SCR::Read( add(p, option) );
	});

	// ensure the needed settings are read (slower than really needed)
	result["comment"] = SCR::Read( add(p, "comment") );
	// synonym: "directory"
	result["path"] = SCR::Read( add(p, "path") );
	
	value = (string) SCR::Read( add( p, "directory" ) );
	if( value != nil && value != result["path"]:nil ) {
	    // translators: error popup on conflicting options, %1 is the name of the
	    // option which will be used, %2 is its value, %3 is the name of the
	    // other option, %4 is the %3's value. %5 is the name of a share
	    Report::Warning( sformat( _("The configuration file contains conflicting
options for share '%5':

%1: %2
%3: %4

YaST2 will use the value of '%1' for now.

Remove one of the options to resolve this conflict.
"), "path", 
	    result["path"]:"", "directory", value, share ) );
	}
	
	result["read list"] = SCR::Read( add(p, "read list") );
	result["write list"] = SCR::Read( add(p, "write list") );
	result["browseable"] = normalize_boolean( (string) SCR::Read( add(p, "browseable") ), true);
	result["guest ok"] = normalize_boolean( (string) SCR::Read( add(p, "guest ok") ), false);
	result["valid users"] = SCR::Read( add(p, "valid users") );
	// synonym: "print ok"
	result["printable"] = normalize_boolean( (string) SCR::Read( add(p, "printable") ), false );

	value = (string) SCR::Read( add( p, "print ok" ) );
	if( value != nil && value != result["printable"]:nil ) {
	    // translators: error popup on conflicting options, %1 is the name of the
	    // option which will be used, %2 is its value, %3 is the name of the
	    // other option, %4 is the %3's value. %5 is the name of a share
	    Report::Warning( sformat( _("The configuration file contains conflicting
options for share '%5':

%1: %2
%3: %4

YaST2 will use the value of '%1' for now.

Remove one of the options to resolve this conflict.
"), "printable", 
	    result["printable"]:"", "print ok", value, share ) );
	}

	result["commentout"] = SCR::Read( add(.etc.smb.section_type, share) ) > 0 ;
	
	return $[ share: result ];
    });
    
    y2debug( "Shares read: %1", shares );

    share_homes = shareEnabled( shares["homes"]:$["commentout":true] );

    // read printer settings
    Progress::NextStage();

    printer_status = $[];
    
    Progress::off();
    import "Spooler";
    
    string spooler = Spooler::checkSpoolSystemNoDialog();
    y2milestone ("Spooler: %1", spooler );
    Spooler::Set (spooler);
    system_printers = Spooler::GetAvailableQueues();
    Progress::on();

    // setup correctly the printer status
    if( haskey( shares, "printers" ) ) {
	// load the system printers
	
	// setup system printer status
	boolean on = shareEnabled( shares["printers"]:$["commentout":true] ) && load_printers;
	
	foreach(  string printer, system_printers , ``{
	    printer_status[ printer ] = on;
	    share_printers = on;
	});
    }
    
    // update printer_status for printable shares
    foreach( string share, map options, shares, ``{
	if( share != "printers" ) {
	    if( options["printable"]:false ) {
		// if the printer was enabled because of printers and it is commented, skip
		// TODO - handle "available" correctly
		boolean on = shareEnabled( options );
		if( ! (printer_status[ share ]: false && !on) ) {
		    printer_status[ share ] = on;
		    if( shareEnabled( options ) ) share_printers = true;
		}
	    }
	}
    });
    
    shares_configured = true;

    // read LDAP settings
    Progress::NextStage();
    
    ReadLDAPSettings();
    
    if(Abort()) return false;
    // translators: progress finished
    ProgressNextStage(_("Finished"));

    modified = false;
    return true;
}

/**
 * Write all samba-server settings
 * @return true on success
 */
global define boolean Write() ``{

    /* Samba-server read dialog caption */
    string caption = _("Saving Samba Server Configuration");
    
    Samba::write_only = true;
    
    Samba::Write();

    if (role != `pdc && service && ! Mode::config)
    {
	// test to join the workgroup
        symbol workgroup_type = CheckWorkgroup( Samba::workgroup );

        if( workgroup_type != `workgroup ) {
            AskJoinDomain( Samba::workgroup, workgroup_type );
	}
    }
    
    integer steps = 3;

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    // translators: write progress stage
	    _("Write the settings"),
	    // translators: write progress stage
	    _("Run SuSEconfig"),
	    // translators: write progress stage
	    !service ? _("Disable Samba services") 
	    // translators: write progress stage
		: _("Enable Samba services")
	], [
	    // translators: write progress step
	    _("Writing the settings..."),
	    // translators: write progress step
	    _("Running SuSEconfig..."),
	    // translators: write progress step
	    ! service ? _("Disabling Samba services...") 
	    // translators: write progress step
		: _("Enabling Samba services..."),
	    // translators: write progress step
	    _("Finished")
	],
	""
    );
    
    // if nothing to write, quit (but show at least the progress bar :-)
    if( ! modified && ! SambaServerPassdb::Modified ()) return true;

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    SambaServerPassdb::Write ();
    
    // revoke trusted domains if needed
    foreach (string domain, boolean stay, trusted_domains, ``{
	if (! stay)
	{
	    // try to revoke
	    if ( (integer) SCR::Execute (.target.bash, 
		"net rpc trustdom revoke " + domain) != 0 )
	    {
		import "Report";
		Report::Error ( sformat (_("Cannot abandon trusted 
domain relationship for '%1'.
"), domain) );
	    }
	}
	else if (Mode::autoinst)
	{
	    // try to establish the domains
	    if ( !EstablishTrustedDomain (domain, trusted_domains_password[domain]:"") )
	    {
		import "Report";
		Report::Error (_("Cannot establish trusted domain relationship.") + " " + domain);
	    }
	}
    });
    
    // check, if we need samba-pdb package
    list<string> rpms = [];
    list<string> backends = SambaServerPassdb::GetBackends ();
    foreach (string bk, backends, ``{
	if ( SambaServerPassdb::BackendSAM (bk) == "mysql" )
	{
	    rpms = add (rpms, "samba-pdb");
	    break;
	}
    });
    
    if (size (rpms) > 0)
    {
	import "Require";
	Require::RequireAndConflictTarget( rpms, [],
    	    // notification about package needed 1/2
	    _("<p>For the configured passdb back-ends, the <b>%1</b> package must be installed.</p>") +
    	    // notification about package needed 2/2
	    _("<p>Do you want to install it now?</p>"));
    }
    
    WriteSettings();
    WriteLDAPSettings();
    
    InstallSchema ();
    
    if (UsingCommonLDAP ())
    {
	// try to setup users plugin
	string res = nil;
	do {
	    // implemented retry for LDAPInit
	    res = Ldap::LDAPInit ();
	    if ( res != "" )
	    {
		if (Mode::autoinst)
		{
		    Report::Error (res);
		}
		else
		{
		    if ( Popup::AnyQuestion ( Popup::NoHeadline(), res, Label::RetryButton(),
			Label::CancelButton (), `focus_yes) )
		    {
			res = nil;
		    }
		}
	    }
	} while (res == nil);
		
	if ( res == "" )
	{
	    Ldap::LDAPAskAndBind (true);

	    Ldap::InitSchema ();
	    
	    res = Ldap::ReadTemplates ();
	    if (res != "")
	    {
		Report::Error (res);
	    }
	    else
	    {
		    string user_template_dn = nil;
		    string group_template_dn = nil;
		    
		    map<string,map<string, any > > templates = 
			(map<string,map<string, any > >)Ldap::GetTemplates ();
		    foreach (string dn, map<string, any > content, templates, ``{
			list<string> classes = content["objectclass"]:[];
			
			foreach (string class, classes, ``{
			    if ( tolower(class) == "suseusertemplate" )
			    {
				user_template_dn = dn;
				break;
			    }
			    else if ( tolower (class) == "susegrouptemplate" ) 
			    {
				group_template_dn = dn;
				break;
			    }
			});
		    });
		    
		    if ( user_template_dn != nil )
		    {
			// found the template
			list<string> plugins = templates[user_template_dn, "suseplugin"]:[];
			if ( !contains (plugins, "UsersPluginSamba") )
			{
			    plugins = add (plugins, "UsersPluginSamba");
			    templates[user_template_dn, "suseplugin"] = plugins;
			    y2milestone ("Updated user templates: %1", plugins);
			    templates[user_template_dn, "modified"] = "edited";
			}
		    }
		    if ( group_template_dn != nil )
		    {
			// found the template
			list<string> plugins = templates[group_template_dn, "suseplugin"]:[];
			if ( !contains (plugins, "UsersPluginSambaGroups") )
			{
			    plugins = add (plugins, "UsersPluginSambaGroups");
			    templates[group_template_dn, "suseplugin"] = plugins;
			    y2milestone ("Updated group templates: %1", plugins);
			    templates[group_template_dn, "modified"] = "edited";
			}
		    }
		    
		    // store the result
		    Ldap::WriteToLDAP (templates);
	    }
	}
    }

    if( !SCR::Write( .etc.smb, nil ) ) {
	// translators: error message
	Report::Error (sformat(_("Cannot write settings to %1."), "/etc/samba/smb.conf") );
    }
    
    // run SuSEconfig for samba
    Progress::NextStage();

    if(Abort()) return false;
    Progress::NextStage ();
    
    enableServer( service );

    if (service)
    {
	// if the service does not run, we can't add the user anyway
	EnsureRootAccount ();    
    }

    if( role == `bdc ) {
	// Retrieve the domain SID for DOMAIN
	map result = (map) SCR::Execute( .target.bash_output, "net rpc getsid" );
	if( result["exit"]:1 != 0 ) {
	    y2debug( "Error retrieving SID: %1", result );
	    // translators: error message
	    Report::Error( _("Unable to retrieve SID for the domain."));
	}
    }
    else
    {
	// ensure that SID gets created
	SCR::Execute (.target.bash, "net getlocalsid" );
    }

    if(Abort()) return false;
    // translators: progress finished
    ProgressNextStage(_("Finished"));

    if(Abort()) return false;
    return true;
}

/**
 * Write all samba-server settings
 * @return true on success
 */
global define boolean WriteSettings() ``{

    // first, write the global settings complete
    foreach( string option, any value, global_config, ``{
	if ( is(global_config[option]:nil, boolean) )
	{
	    SCR::Write( add(.etc.smb.value.global, option), (boolean)value ? "yes" : "no" );
	}
	else
	{
	    SCR::Write( add(.etc.smb.value.global, option), value );
	}
    });    
    
    // write global settings
    if (netbios_name == "")
    {
	// if not set, try to delete
	SCR::Write( .etc.smb.value.global."netbios name", nil);
    }
    else
    {
	SCR::Write( .etc.smb.value.global."netbios name", netbios_name);
    }

    SCR::Write( .etc.smb.value.global."add machine script", add_machine_script );
    if( domain_master != "auto" ) 
	SCR::Write( .etc.smb.value.global."domain master" , domain_master );
    SCR::Write( .etc.smb.value.global."preferred master" , preferred_master );
    if( !load_printers )
        SCR::Write( .etc.smb.value.global."load printers", load_printers ? "yes" : "no" );
    
    // ensure "encrypt passwords = yes";
    SCR::Write( .etc.smb.value.global."encrypt passwords" , "yes" );
    
    // ensure high os level for PDC
    if( role == `pdc ) {
	string val = (string) SCR::Read( .etc.smb.value.global."os level" );
	if( val == nil || tointeger(val) < 65 ) {
	    SCR::Write( .etc.smb.value.global."os level", 65 );
	}
    }
    
    // remove removed shares first
    foreach( string share, map options, removed_shares, ``{
	SCR::Write( add( .etc.smb.section, share ), nil );
    });

    // write shares
    foreach( string share, map<string, any> options, shares, ``{
	// write the options
	
	// prepare the right type for writing out the value
	integer type = ( options["commentout"]:false ) ? 1 : 0;
	
	// write the type of the section
	SCR::Write( add(.etc.smb.section_type, share), type );
	
	// write all the options
	path sectionpath = add( .etc.smb.value, share );
	path sectiontypepath = add( .etc.smb.value_type, share );
	foreach( string opt, any value, options, ``{
	    // skip our internal options
	    if( value != nil && opt != "commentout" && opt != "yast" ) {

		if( is( value, string ) )
		{
		    SCR::Write( add(sectionpath, opt), value );
		} else {
		    // it must be boolean
		    SCR::Write( add(sectionpath, opt), (boolean) value ? "yes": "no" );
		}
		if( value != nil ) SCR::Write( add(sectiontypepath, opt), type );
	    }
	});
    });
    
    WriteLDAPSettings();
    
    // commit the changes
    boolean res = SCR::Write (.etc.smb, nil);
    
    if (res)
    {
	import "Directory";
	SCR::Execute (.target.bash, "touch " + Directory::vardir + "/samba_server_done_once" );
    }
    
    return res;
}

/**
 * Get all samba-server settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (map settings) ``{

    if( settings == $[] ) {
	globals_configured = false;
	shares_configured = false;
	
	global_config = $[];
	role = `standalone;
	service = false;

	domain_master = "auto";
	preferred_master = "auto";
	add_machine_script = "";
	share_homes = false;
	share_printers = false;
	load_printers = true;
	LDAP_admin_dn = nil;
	LDAP_suffix = nil;
	shares = $[];
	printer_status = $[];
	netbios_name = "";
	
	SambaServerPassdb::SetBackends ([]);
	
	Samba::Import ($[]);
	
	trusted_domains = $[];
	trusted_domains_password = $[];
	
	return true;
    }
    
    y2milestone( "Importing: %1", settings );

    string version = settings["version"]:"";
    
    Samba::Import( settings["client"]:$[] );
    
    global_config = listmap( map opts, settings["global"]: [], ``{
		return $[ opts["key"]:"unknown": opts["value"]: nil ];
    } );
    
    role = (symbol) (name2role[ settings["role" ]: "File and printer sharing" ]:`standalone);
    share_homes = global_config["share_homes"]: share_homes;
    share_printers = global_config["share_printers"]: share_printers;
    netbios_name = global_config["netbios name"]: "";
    
    if (haskey (global_config, "workgroup") )
    {
	Samba::setWorkgroup (  global_config ["workgroup"]:"" );
    }
    
    SambaServerPassdb::SetBackends ( splitstring ( global_config["passdb backends"]:"", " ") );

    LDAP_admin_dn = global_config["LDAP admin dn"]: LDAP_admin_dn;
    LDAP_suffix = global_config["LDAP suffix"]: LDAP_suffix;
    
    service = settings["service"]:false;
    
    list< map<string,string> > trusted = settings["trusteddomains"]: [];
    
    foreach (map<string,string> domain, trusted, ``{
	if (haskey (domain, "domain") )
	{
	    trusted_domains[ domain["domain"]:"" ] = true;
	    trusted_domains_password[ domain["domain"]:"" ] = domain["password"]:"";
	}
    });
    
    globals_configured = true;

    // read shares
    shares = listmap( map key, settings["shares"]:[], ``{
	return( $[ key["share"]:"unknown": 
	    listmap( map opts, key["options"]: [], ``{
		return $[ opts["key"]:"unknown": opts["value"]: nil ];
	    } ) ] );
    });
    
    shares_configured = haskey (settings, "shares");
    
    return true;
}

/**
 * Dump the samba-server settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{

    map result = $[ "client" : Samba::Export() ];
    
    result["version"] = "2.9";
    
    string passdb = mergestring (SambaServerPassdb::GetBackends (), " ");

    if ( size(passdb) > 0 )
    {
	global_config[ "passdb backend" ] = passdb;
    }
    
    if ( size(netbios_name) > 0 )
    {
	global_config[ "netbios name" ] = netbios_name;
    }
    
    list r_shares =  maplist( string share, map<string,any> options, shares, ``{
	return $[ 
	    "share" : share, 
	    "options" : maplist( string key, any value, options, ``{
		return $[ "key": key, "value" : value ];
	    })
	];
    });
    
    if (size (global_config) > 0 )
    {    
	result[ "global" ]  = maplist( string key, any value, global_config, ``{
		return $[ "key" : key, "value" : value ];
	} );
    }

    if( size(r_shares) > 0 ) result ["shares"] = r_shares;
    
    list trusted = [];
    foreach (string domain, boolean stay, trusted_domains, ``{
	if (stay)
	{
	    trusted = add (trusted, $[ "domain" : domain, "password" : trusted_domains_password[domain]:"" ] );
	}
    });
    
    if (size (trusted) > 0)
    {
	result ["trusteddomains"] = trusted;
    }
    
    result ["service"] = service;
    result ["role"] = role2name[ role ]: "Standalone server";

    return result;
}

/**
 * Create a textual summary and a list of unconfigured options
 * @return summary of the current configuration
 */
global define string Summary() ``{
    
    import "Summary";
    
    string nc = Summary::NotConfigured ();
    
    // summary header
    string summary = Summary::AddHeader("", _("Global Configuration"));
    
    if( globals_configured ) {
	// summary item: configured workgroup/domain
	summary = Summary::AddLine(summary, sformat(_("Workgroup or Domain: %1"), Samba::workgroup ) );
	
	if( ! service ) {
	    // summary item: status of the samba service
	    summary = Summary::AddLine(summary, _("Samba server is <i>disabled</i>") );
	} else {
	    // summary item: selected role for the samba server
	    summary = Summary::AddLine(summary, sformat(_("Role: %1"), roleName(role) ) );
	}
    } else {
	summary = Summary::AddLine(summary, nc );
    }
    
    // summary heading: configured shares
    summary = Summary::AddHeader(summary, _("Share Configuration"));
    
    if( shares_configured ) {
	if( size( shares ) == 0 ) {
	    // summary item: no configured shares
	    summary = Summary::AddLine(summary, _("none") );
	} else {
	    summary = Summary::OpenList(summary);
	    foreach( string share, map options, shares, ``{
		if( options["path"]:nil != nil )
		    summary = Summary::AddListItem( summary, sformat( "%1 (<i>%2</i>)", share, options["path"]:"" ) );
		else
		    summary = Summary::AddListItem( summary, share );
		
		if( options["comment"]:nil != nil )
		    summary = Summary::AddLine( summary, options["comment"]:"" );
	    });
	    summary = Summary::CloseList(summary);
	}
    } else {
	summary = Summary::AddLine(summary, nc );
    }

    return summary;
}

global void setServiceEnabled( boolean on ) {
    if ( on != service )
    {
	service = on;
	modified = true;
    }
}

global boolean ServiceEnabled () {
    return service;
}

/** 
 * Turn on/off SAMBA server services (smb and nmb).
 *
 * @param on 		should be enabled?
 * @return boolean 	true on success
 */
global define boolean enableServer( boolean on ) ``{
    if (on)
    {
	Service::Enable( "nmb" );
	Service::Enable( "smb" );
    }
    else
    {
	Service::Disable( "nmb" );
	Service::Disable( "smb" );
    }
    
    if( write_only ) return true;
    
    boolean reload = false;
    
    if( on ) {
    
	// check, if the services run
	if( Service::Status( "nmb" ) != 0 ) {
	    // the service does not run
	    if( ! Service::Start( "nmb" ) ) {
		// translators: error message
		Report::Error( _("Cannot start 'nmb' service.") );
		return false;
	    }
	} else reload = true;
	if( Service::Status( "smb" ) != 0 ) {
	    // the service does not run
	    if( ! Service::Start( "smb" ) ) {
		// translators: error message
		Report::Error( _("Cannot start 'smb' service.") );
		return false;
	    }
	} else reload = true;
    
	if( reload ) ReloadSettings();
    } 
    else 
    {
	// turn services off
	if( Service::Status( "nmb" ) == 0 ) {
	    if( ! Service::Stop( "nmb" ) ) {
		// translators: error message
		Report::Error( _("Cannot stop 'nmb' service.") );
		return false;
	    }
	}

	if( Service::Status( "smb" ) == 0 ) {
	    if( ! Service::Stop( "smb" ) ) {
		// translators: error message
		Report::Error( _("Cannot stop 'smb' service.") );
		return false;
	    }
	}
    }
    
    return true;

}

/**
 * Set the server description
 *
 * @param description a new description
 */
global define void setDescription( string description ) ``{
    if( global_config["server string"]:nil != description ) {
	global_config["server string"] = description;
	modified = true;
    }
}

/**
 * Get the server description string.
 *
 * @return the string or nil, if not set
 */
global string getDescription ()
{
    return global_config["server string"]:(string)nil;
}

/** 
 * Turn on/off [printers]
 *
 * @param on 		should be enabled?
 */
global  define void enablePrinters( boolean on ) ``{
    if( share_printers != on ) {
	share_printers = on;

	// if they should be turned off and there is no such share, done
	if( !on ) disableAllPrinters();
	else {
	    enableShare( "printers", true );
	    enableAllSystemPrinters();
	}

	modified = true;
    }
}

/** 
 * Turn on all system printers. Will enable [printers] as well.
 */
global define void enableAllSystemPrinters() ``{
    foreach(  string printer, system_printers, ``{
	printer_status[ printer ] = true;
	share_printers = true;
    });
}

/** 
 * Turn on/off [homes]
 *
 * @param on 		should be enabled?
 */
global define void enableHomes( boolean on ) ``{
    if( share_homes != on ) {
	share_homes = on;

	// if they should be turned off and there is no such share, done
	if( ! on && ! haskey( shares, "homes" ) ) return;
	
	if( ! haskey( shares, "homes" ) ) {
	    // add a reasonable default
	    shares["homes"] = default_homes;
	}
	
	shares["homes", "commentout"] = !on;
    
	modified = true;
    }
}

/** 
 * Turn on/off [netlogon] and domain logons
 *
 * @param on 		should be enabled?
 */
global define void enableNetlogon( boolean on ) ``{
    global_config["domain logons"] = true;
    
    // if there is [netlogon] share
    if( haskey(shares, "netlogon") ) {
	shares["netlogon", "commentout"] = on;
    } else 
    // there is no [netlogon], but should be
    if( on ) {
	shares["netlogon"] = $[
	    "comment": "Network Logon Service",
            "path": "/var/lib/samba/netlogon",
            "write list": "root",
	    "commentout": false
	];
    }
    
    modified = true;
}

global void AdaptMachineScript () {
    if ( SambaServerPassdb::LDAPDefault () )
    {
	add_machine_script = "/sbin/yast /usr/share/YaST2/data/add_machine.ycp %m$";
    }
    else
    {
	add_machine_script = "/usr/sbin/useradd  -c Machine -d /var/lib/nobody -s /bin/false %m$";
    }
    
    global_config ["add machine script"] = add_machine_script;
}

/** 
 * Configure as PDC. Does NOT set @ref role.
 *
 * @return boolean	true on success
 */
global define boolean setAsPDC() ``{
    Samba::security = "user";
    global_config[ "domain logons"] = true;
    preferred_master = "yes";
    domain_master = "yes";
    global_config[ "local master"] = true;
    
    AdaptMachineScript ();
    
    Samba::setDomainMembershipLevel( "pdc");
    role = `pdc;
    
    return true;
}

/** 
 * Configure as BDC. Does NOT set @ref role.
 *
 * @return boolean	true on success
 */
global define boolean setAsBDC() ``{
    domain_master = "false";
    global_config ["domain logons"] = true;
    Samba::security = "user";
    Samba::setDomainMembershipLevel( "bdc");
    
    role = `bdc;
    
    return true;
}

/** 
 * Configure as a standalone server (no domain logons) Does NOT set @ref role.
 *
 * @return boolean	true on success
 */
global define boolean setAsStandalone() ``{
    domain_master = "false";
    global_config ["domain logons"] = false;
    Samba::setDomainMembershipLevel( "member");
    
    role = `standalone;

    return true;
}

/** 
 * Configure for a given role. Calls @ref setAsPDC, @ref setAsBDC and @ref setAsStandalone
 * Setup @ref role variable.
 *
 * @param  new_role	the new role
 * @return boolean	true on success
 */
global define boolean setRole( symbol new_role ) ``{

    // if no change, success
    if( role == new_role ) return true;
    
    modified = true;
    
    role = new_role;
    
    if( role == `pdc ) return setAsPDC();
    else if( role == `bdc ) return setAsBDC();
    else if( role == `standalone ) return setAsStandalone();
    
    return true;
}

/**
 * Set the LDAP server administration DN.
 *
 * @param dn	administration dn
 */
global define void setLDAPAdminDN( string dn ) ``{
    if( LDAP_admin_dn == dn ) return;
    
    LDAP_admin_dn = dn;
    modified = true;
}

/**
 * Set the LDAP server suffix
 *
 * @param suffix	suffix dn
 */
global define void setLDAPSuffix( string suffix ) ``{
    if( suffix == LDAP_suffix ) return;
    
    LDAP_suffix = suffix;
    modified = true;
}

/**
 * Reload settings for smbd and nmbd. Calls the initscripts with restart
 * to switch backend if necessary.
 *
 * @return boolean	true on success
 */
global define boolean ReloadSettings() ``{
    integer ret = (integer) SCR::Execute( .target.bash, "/usr/sbin/rcsmb restart" );
    
    if( ret != 0 ) {
	y2error( "/usr/sbin/rcsmb restart failed: %1", ret );
    }
    
    boolean result = ret == 0;
    
    ret = (integer) SCR::Execute( .target.bash, "/usr/sbin/rcnmb restart" );
    
    if( ret != 0 ) {
	y2error( "/usr/sbin/rcnmb restart failed: %1", ret );
    }
    
    return result && ret == 0;
}

/**
 * Read LDAP-related settings.
 */
global define void ReadLDAPSettings() ``{
    LDAP_admin_dn = (string) SCR::Read( .etc.smb.value.global."ldap admin dn" );
    LDAP_suffix = (string) SCR::Read( .etc.smb.value.global."ldap suffix" );

    // we miss some information, ask LDAP for defaults
    import "Ldap";
    Ldap::Read();

    if( LDAP_admin_dn == nil ) {
	// ask LDAP client about default configuration DN
	if( LDAP_admin_dn == nil )
	    LDAP_admin_dn = Ldap::bind_dn;
	// ask LDAP client about default search DN
	if( LDAP_suffix == nil )
	    LDAP_suffix = Ldap::GetDomain();
    }
    
    // ensure LDAP suffixes and idmap backend
    if ( global_config["ldap machine suffix"]:nil == nil)
    { 
	global_config["ldap machine suffix"] = "ou=Computers";
    }
    if ( global_config["ldap idmap suffix"]:nil == nil)
    {
	global_config["ldap idmap suffix"] = "ou=Idmap";
    }
    if ( global_config["idmap backend"]:nil == nil)
    {
	// check, if we use LDAP backend
	if ( SambaServerPassdb::LDAPDefault () )
	{
	    global_config["idmap backend"] = select( SambaServerPassdb::GetBackends (), 0, "");
	}
    }
}

/**
 * Write LDAP-related settings.
 */
global define void WriteLDAPSettings() ``{
    // delete if not neccessary
    if( LDAP_admin_dn == "" ) LDAP_admin_dn = nil;
    if( LDAP_suffix == "" ) LDAP_suffix = nil;
    
    if( LDAP_suffix != nil )
    {
	global_config ["ldap suffix"] = LDAP_suffix;
    }
    
    // otherwise comment out if necessary
    SCR::Write( .etc.smb.value.global."ldap admin dn", LDAP_admin_dn );
    SCR::Write( .etc.smb.value.global."ldap suffix", LDAP_suffix );
    
    if ( !haskey (global_config, "idmap  backend") && SambaServerPassdb::LDAPDefault () )
    {
	global_config["idmap backend"] = select( SambaServerPassdb::GetBackends (), 0, "");	
    }
    
    // create ldap machine and idmap suffix
if ( haskey (global_config, "ldap suffix")
	&& SambaServerPassdb::LDAPDefault ())
{
list<string> subSuffixList = [ "machine", "idmap" ];

// FIXME: this will not use the correct server for idmap, it will use the same
// one as passdb backend
foreach (string subSuffix, subSuffixList, ``{
	string ldapParamName = "ldap " + subSuffix + " suffix";
    if ( haskey(global_config, ldapParamName)) 
    {
	// find our host - first LDAP backend
	list<string> backends = SambaServerPassdb::GetBackends ();
	string backend = backends[0]:""; // we know it's LDAP, because it's default
	map url = URL::Parse (SambaServerPassdb::BackendDetails (backend));
	string host = (string) url["host"]:nil;

	// check existence of machine and idmap suffix
	SCR::Execute (.ldap, $[ "hostname" : host ]);
	
	string dn = global_config[ldapParamName]:"" + ","+global_config["ldap suffix"]:"";
	list res = (list)SCR::Read (.ldap.search, $["base_dn" : dn, "scope": 0, "not_found_ok" : true]);
	
	if ( size(res) == 0 )
	{
	    // try to create a reasonable object to add
	    list<string> dn_parts = splitstring (
		global_config[ldapParamName]:"",
		" ");
		
	    if ( size(dn_parts) != 1 )
	    {
		y2warning (subSuffix + " suffix is too complicated: %1", dn_parts);
		return;
	    }
	    
	    dn_parts = splitstring ( dn_parts[0]:"", "=" );
	    map to_add = $[];
	    
	    string class = tolower( dn_parts[0]:"" );
	    if ( class == "ou" )
	    {
    		to_add[ "objectclass" ] = [ "top", "organizationalunit"];
		to_add[ "ou" ] = dn_parts[1]:"";
	    }
	    else
	    {
		y2warning (subSuffix + " suffix is too complicated: %1", class);
		return;
	    }
	    
	    // try to bind
	    map <string, string> secrets = SambaSecrets::Read ();
    
	    if (secrets == nil )
	    {
		y2warning ("Cannot get LDAP password");
		return;
	    }
    
	    string password = nil;
    
	    foreach (string key, string data, secrets,``{
		if ( regexpmatch ( key, "SECRETS/LDAP_BIND_PW/"+LDAP_admin_dn ) )
		{
		    password = regexpsub (data, "(.*)\\\\00", "\\1");
		}
	    });
	    
	    if (password == nil)
	    {
		y2warning ("Cannot find LDAP bind password, skipping " + subSuffix + " suffix creation");
		return;
	    }
	    
	    if ( SCR::Execute (.ldap.bind
		, $["bind_dn" : LDAP_admin_dn, "bind_pw" :password]) != true)
	    {
		map error = (map)SCR::Read (.ldap.error);
		y2warning ("Cannot bind for creating " + subSuffix + " suffix" + "\n"+ error["msg"]:"");
		return;
	    }
	    
	    
	    
	    SCR::Write (.ldap.add, $[ "dn" : dn ], to_add);
        }
    }
}); // end of foreach subSuffixList
}
    // try to lookup user/group suffix   
    if (UsingCommonLDAP ())
    {
	string res = Ldap::LDAPInit ();
	if ( res != "" )
	{
	    // forget it
	    return;
	}
	Ldap::ReadConfigModules ();
	map< string, map<string,any> > conf = (map< string, map<string,any> >)Ldap::GetConfigModules ();
	
	y2debug ("Config modules: %1", conf );
	foreach ( string dn, map<string,any> c, conf, ``{
	    list<string> classes = c["objectclass"]:[];
	    classes = maplist( string val, classes, ``(tolower(val)) );
	    if ( contains (classes, "suseuserconfiguration") && ! haskey (global_config, "ldap user suffix"))
	    {
		list<string> parts = splitstring (c["susedefaultbase",0]:"", ",");
		global_config ["ldap user suffix"] = parts[0]:"";
		SCR::Write (.etc.smb.value.global."ldap user suffix", parts[0]:nil);
	    }
	    else if ( contains (classes, "susegroupconfiguration") && ! haskey (global_config, "ldap group suffix"))
	    {
		list<string> parts = splitstring (c["susedefaultbase",0]:"", ",");
		global_config ["ldap group suffix"] = parts[0]:"";
		SCR::Write (.etc.smb.value.global."ldap group suffix", parts[0]:nil);
	    }
	});
    }
}

/**
 * Setup LDAP admin password using smbpasswd -w. Switches backend to LDAP first.
 *
 * @param password	the new password
 * @return string 	nil for success, error message otherwise
 */
global define string setLDAPAdminPassword( string password ) ``{
    // first, try to do a bind

    // find our host - first LDAP backend
    list<string> backends = SambaServerPassdb::GetBackends ();
    string host = nil;
    foreach ( string backend, backends, ``{
	string type = tolower(SambaServerPassdb::BackendSAM (backend));
	if ( type == "ldap" || type == "ldapsam" )
	{
	    map url = URL::Parse (SambaServerPassdb::BackendDetails (backend));
	    host = (string) url["host"]:nil;
	    break;
	}
    });

    // there is the backend    
    if ( host != nil )
    {
	y2milestone ("host for checking: %1", host);
	SCR::Execute (.ldap, $[ "hostname" : host ]);
	if ( SCR::Execute (.ldap.bind
	    , $["bind_dn" : LDAP_admin_dn, "bind_pw" :password]) != true)
	{
	    map error = (map)SCR::Read (.ldap.error);
	    // translators: Setting LDAP bind password failed.
	    return _("Cannot set the password.") + "\n"+ error["msg"]:"";
	}
    }
    
    // write the LDAP settings now, otherwise secrets.tdb would contain
    // a wrong entry (#40866)
    WriteLDAPSettings ();
    SCR::Write ( .etc.smb, nil );
    
    string cmd = "smbpasswd -w '"+password+"'";
    map result = (map) SCR::Execute( .target.bash_output, cmd );
    
    // check the exit code, return nil on success
    if( result["exit"]:1 == 0 ) return nil;

    // translators: unknown error when setting the LDAP password    
    string res = result["stderr"]:_("Cannot set the password.");
    // otherwise return stderr
    return size(res)==0 ? _("Cannot set the password.") : res;
}

/**
 * Test LDAPS connection to the server using ldapsearch.
 *
 * @param server	the LDAPS server
 * @param search_base	base to be tested
 *
 * @return boolean	true on success
 */
global define boolean testLDAPS( string server, string search_base ) ``{
    map result = (map) SCR::Execute( .target.bash_output, "ldapsearch -x -H "+server+" -b "+search_base );
    y2debug( "LDAP test search result: %1", result );
    if( result["exit"]:-1 != 0 ) {
	// translators: warning message, %1 is LDAP server name/IP
	Report::Warning( sformat( _("It seems like there is no functional
LDAP server at %1.
"), server ) );
	return false;
    }
    
    return true;
}

/**
 * Disable all printers.
 */
global define void disableAllPrinters() ``{
    // disable each share with printable = true
    foreach( string share, map options, shares, ``{
	if( options["printable"]:false ) enableShare( share, false );
    });
}

/**
 * Enable printers in a list. If possible, use [printers] section
 *
 * @param enable_names	list of printer names to be enabled
 */
global define void enablePrinterNames( list<string> enable_names ) ``{
    
    y2debug( "System printers are: %1", system_printers );
    y2debug( "Enable: %1", enable_names );
    
    // first, check, if we can use [printers]
    boolean printers = true;
    foreach( string name, system_printers, ``{
	// each system printer must be enabled and not disabled
	if( (printer_status[name]:false) && !contains( enable_names, name ) ) {
	    printers = false;
	    y2debug( "[printers] can't be used, because of %1", name );
	}
    });
    
    enableShare( "printers", printers );
    // if we can use [printers]
    if( printers ) {
	// filter out printers enabled by [printers]
	enable_names = filter( string name, enable_names, ``( !contains( system_printers, name ) ) );
	// remove yast-defined shares
	shares = filter( string name, map<string,any> options, shares, ``( ! (options["yast"]:false) ) );
    }
    
    // update the status of these printers
    foreach( string name, system_printers, ``{
	printer_status[ name ] = printers;
	// if printers are used, do not use the shares themselves
	if( printers ) {
	    enableShare( name, false );
	}
    });
    
    // work on enable_names
    y2debug( "Now need to work on %1", enable_names );
    foreach( string name, enable_names, ``{
	if( haskey( shares, name ) ) {
	    if( shares[name, "printable"]:false == true ) {
		printer_status[ name ] = true;
		enableShare( name, true );
		y2debug( "Enabling printer %1", name );
	    }
	    else 
	    {
		// a share with the same name, but without printable!!!
		y2error( "Share '%1' is not printable: %2", name, shares[name]:$[] );
		// translators: error message. There is a given share, but configured differently
		Report::Error( sformat( _("There is already a share '%1',
but it is not configured
as a printer.\n
YaST2 will not modify this share."), name ) );
	    }
	}
	else 
	{
	    y2debug( "Adding a share for printer %1", name );
	    // no share, create one
	    shares[ name ] = eval(default_printer_share);
	    printer_status[ name ] = true;
	    enableShare( name, true );
	}
    });
    
    modified = true;
}

/**
 * Are some of the system printers enabled?
 *
 * @return boolean	true if yes
 */
global define boolean SystemPrintersEnabled() ``{
    boolean result = false;
    foreach( string printer, system_printers, ``{
	if( printer_status[ printer ]:false ) result = true;
    });
    
    return result;
}

/**
 * Removes the share's configuration.
 * 
 * @param name	name of a share
 * @return boolean	true on success, false if the share does not exist
 */
global define boolean removeShare( string name ) ``{
    // if there is no such share, done
    if( !haskey( shares, name ) ) return false;

    removed_shares[name]  = shares[name]: nil;

    shares = remove( shares, name );
    
    // update the printer lists
    if( haskey( printer_status, name ) ) printer_status = remove( printer_status, name );
	
    modified = true;
    
    //success
    return true;
}

global define map<string,any> getShare (string name)
{
    // share does not exist
    if( ! haskey( shares, name ) ) return nil;
    
    return shares[name]:nil;
}

/**
 * Adds a new share.
 * 
 * @param name		name of a share
 * @param options	configuration of the share
 * @return boolean	true on success, false if the share already exists
 */
global define boolean addShare( string name, map<string,any> options ) ``{
    // share already exists
    if( haskey( shares, name ) ) return false;
    
    shares[name] = options;
    
    modified = true;
    
    // success
    return true;
}

/**
 * Enable/disable a share, does not remove its configuration.
 * 
 * @param name		name of a share
 * @param on		should be enabled?
 * @return boolean	true on success, false if the share does not exist
 */
global define boolean enableShare( string name, boolean on ) ``{

    // if there is no such share, exit
    if( !haskey( shares, name ) ) return false;
    
    // [printers] is coupled with "load printers"
    if( name == "printers" ) load_printers = on;
    
    shares[ name, "commentout" ] = !on;
    
    modified = true;
    
    return true;
}

/**
 * Update the share configuration,
 * 
 * @param name		name of a share
 * @param options	new options of the share
 * @return boolean	true on success, false if the share does not exist
 */
global define boolean updateShare( string name, map<string,any> options ) ``{

    // share does not exists
    if( !haskey( shares, name ) ) return false;
    
    shares[name] = options;
    
    modified = true;
    
    return true;
}

/**
 * Map role to a localized text.
 *
 * @param role		symbol of the role
 * @return string	localized role name
 */
global define string roleName( symbol role ) ``{
    locale s = role2name[role]:"";
    return (string) eval(s);
}

/**
 * Find out the role of a server using the read settings
 *
 * @return symbol	the role it appears to be
 */
global define symbol DetermineRole() ``{
    if( Samba::security == "user" )
    {
	if( global_config["domain logons"]:false 
	    && yes_or_auto( domain_master ) 
	    && yes_or_auto( preferred_master ) 
	    && global_config["local master"]:true ) {
	    return `pdc;
	}
	else if( ! yes_or_auto(domain_master) 
	    && global_config["domain logons"]:false )
	{
	    return `bdc;
	}
	else 
	{
	    return `standalone;
	}
    }
    
    return `standalone;
}

/**
 * Return required packages for auto-installation
 * @return map of packages to be installed and to be removed
 */
global define map<string,list<string> > AutoPackages() ``{
    return ($["install": required_packages, "remove": []]);
}


global map<string, map<string,any> > ProposeRole(string workgroup) {
    Samba::CheckNmbstatus();
    
    // by default, propose PDC
    map<string, map<string,any> > ret = $[
	"pdc" : $[
	    "propose" : true,
	    "possible" : true,
	    "message" : "",
	],
	"bdc" : $[
	    "propose" : false,
	    "possible" : true,
	    "message" : "",
	],
	"standalone" : $[
	    "propose" : false,
	    "possible" : true,	// this should be available alwyas
	    "message" : "",
	],
    ];
    
    boolean has_pdc = false;
    boolean has_bdc = false;
    boolean samba_pdc = true;
    
    if ( haskey (Samba::nmbstatus_output,workgroup) )
    {
	has_pdc = Samba::nmbstatus_output[workgroup, "PDC"]:nil != nil;
	has_bdc = Samba::nmbstatus_output[workgroup, "BDC"]:nil != nil;
	# FIXME: samba_pdc 
    }
    
    y2milestone( "In proposal: has_pdc: %1, has_bdc: %2, samba_pdc: %3",
	has_pdc, has_bdc, samba_pdc);
    
    // now, propose
    if (has_pdc)
    {
	// we can't be PDC
	ret["pdc", "propose"] = false;
	ret["pdc", "possible"] = false;
	ret["pdc", "message" ] = _("Not available because PDC is present.");
	ret["bdc", "propose"] = samba_pdc;
	if (!samba_pdc)
	{
	    ret["bdc", "possible"] = false;
	    ret["bdc", "message"] = _("Not available because PDC is not a Samba server.");
	}
	ret["standalone", "propose"] = ! samba_pdc;
    }
    else if (has_bdc)
    {
	ret["pdc","propose"] = false;
	ret["pdc","message"] = _("At least one BDC, but no PDC found.");
	
	if (!samba_pdc)
	{
	    ret["bdc", "possible"] = false;
	    ret["bdc", "message"] = _("Not available because PDC is not a Samba server.");
	}
	ret["standalone", "propose"] = ! samba_pdc;
    }
    
    return ret;
}

global boolean EstablishTrustedDomain (string domain, string password)
{
    if (Mode::config)
    {
	trusted_domains[domain] = true;
	trusted_domains_password [domain] = password;
	
	modified = true;
	return true;
    }
    else
    {
	y2milestone ("Establishing trust domain relationship for '%1'", domain);
    
	if ( 0 == (integer) SCR::Execute (.target.bash, 
	    "net rpc trustdom establish " + domain + " -Uroot%" +  password ) )
	{
	    trusted_domains [domain] = true;
	    modified = true;
	    return true;
	}
    }
    
    return false;
}

global boolean CreateRootAccount (string password)
{
    string tmp = (string)SCR::Read (.target.tmpdir) + "/inp";
    
    if (! SCR::Write ( .target.string, tmp, password + "\n" + password + "\n" ) )
    {
	y2error ("Failed to prepare pdbedit input");
	return false;
    }
    
    string cmd = "cat " + tmp + " | pdbedit -a -t -u root";

    y2milestone ("Running: %1", cmd);
	
    if (SCR::Execute (.target.bash, cmd) != 0)
    {
	y2error ("Failed to execute pdbedit");
	return false;
    }
        
    return true;
}

global boolean ExistsAccount (string username)
{
    map output = (map)SCR::Execute (.target.bash_output, "rpcclient -U% localhost -c enumdomusers" );
    y2milestone ("Found users: %1", output);
    
    if (output["exit"]:-1 == 0)
    {
	list<string> lines = splitstring ( output["stdout"]:"", "\n");
	boolean found = false;
	foreach (string line, lines, ``{
	    if ( issubstring (line, "user:["+username+"]") )
	    {
		found = true;
		break;
	    }
	});
	
	return found;
    }
    
    y2error ("Failed to lookup existing users");
    return false;
}

boolean EnsureRootAccount ()
{
    if ( ExistsAccount ("root") || Mode::autoinst || Mode::test) 
    {
	return true;
    }
    
    // try to create it
    
    // first, ask for password
    UI::OpenDialog(
	`HVSquash(
        `VBox(
	    `Label ( _("For a proper function, Samba server needs an
administrative account (root).
It will be created now."),
	    `Password(`id(`passwd1), _("&Enter a password for the Samba root user:") ,
            `Password(`id(`passwd2), _("Reenter the password for &verification:") ),
                `HBox(
                    `PushButton(`id(`ok), `opt(`default), Label::OKButton() ),
                    `PushButton(`id(`cancel), Label::CancelButton() )
                )
            )
	))));

    any ret = nil;
    string passwd = nil;
    
    do {
	ret = UI::UserInput();
    
	if (ret == `cancel)
	{
	    // user skipped
	    UI::CloseDialog();
	    return true;
	}
	
	// ret is `ok
        string passwd1 = (string) UI::QueryWidget(`id(`passwd1), `Value);
        string passwd2 = (string) UI::QueryWidget(`id(`passwd2), `Value);
	
	if ( passwd1 != passwd2 )
	{
	    Popup::Error (_("The first and the second version\nof the password don't match!\nPlease try again."));

	    ret = nil;
	}
	else
	{
	    passwd = passwd1;
	}
    } while (ret == nil);


    UI::CloseDialog();

    if (!CreateRootAccount (passwd))
    {
	Popup::Error ( sformat(_("Cannot create account for user %1."), "root" ) );
	return false;
    }
    
    return true;
}

/* EOF */
}
