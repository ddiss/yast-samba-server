/**
 * File:	modules/TabWidget.ycp
 * Package:	TabWidget dialogs backend
 * Summary:	Routines for tabbed interface
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *		Stanislav Visnovsky <visnov@suse.cz>
 *
 * $Id$
 *
 */

{

    module "TabWidget";
    textdomain "samba-server";

    import "CWM";
    import "Label";
    import "Mode";
    import "Report";
    import "Wizard";

    boolean has_fancy_gui = false;

// variables
    // this is statefull module!!!
    list<string> ids = [];
    string current_tab = nil;
    map<string, map<string,any> > tabs = $[];
    map<string, list<map<string, any> > > contents_cache = $[];
    
    string lazy_switch_tab = nil;

    /**
      * Update the option description map in order to contain handlers of
      *  all needed functions
      * global only because of testsuites
      * @param opt_descr map option description map
      * @param fallbacks map of fallback handlers
      * @return map updated option description map
      */
    global define map<string, any> updateOptionMap (map<string, any> opt_descr, map fallbacks) ``{
	return opt_descr;
    }

    /**
      * Redraw completely the widget
      * @param descr map description map of the whole widget
      * @param update_buttons boolean true if buttons status (enabled/disabled)
      *  should be updated according to currently selected item
      */
    define void WidgetRedraw (map<string, any> descr) ``{
	term w = tabs[current_tab, "widget"]:`VSpacing(0);
	
	UI::ReplaceWidget ( `_tab_contents, w );
	Wizard::SetHelpText ( tabs[current_tab, "help"]:"" );
	
	return;
    }
    
    global void SwitchToTab (string id) {
	lazy_switch_tab = "__" + id;
    }
    
    map<symbol,symbol> value_property = $[
	`Table : `Items,
	`PushButton : `Enabled, 	// this is a bit hackish - storing enabled/disabled buttons
    ];
    
    list<map<string, any> > TraverseAndStoreValues (term widget, list<map<string, any> > so_far)
    {
        integer args = size (widget);
        if (args == 0)
            return so_far;

        integer index = 0;
        symbol current = symbolof (widget);
	
	if ( contains ( [`ComboBox, `TextEntry, `CheckBox, `RadioButton, `Table, `PushButton], current ) )
	{
	    any id = widget[0,0]: nil;
	    
	    y2debug ("Adding: %1", $[
		"widget" : current,
		"value" : UI::QueryWidget (`id(id), value_property [current]:`Value),
		"enabled" : UI::QueryWidget (`id(id), `Enabled ),
		"id" : id,
	    ]);
	    so_far = add (so_far, $[
		"widget" : current,
		"value" : UI::QueryWidget (`id(id), value_property [current]:`Value),
		"enabled" : UI::QueryWidget (`id(id), `Enabled ),
		"id" : id,
	    ]);
	}
	else while (index < args)
        {
            any arg = widget[index]: nil;
	    if ( is( arg, term) )
	    {
		so_far = TraverseAndStoreValues ( (term)arg, so_far);
	    }
            index = index + 1;
        }
        return so_far;
    }
    
    void RestoreValues (list<map<string, any> > values)
    {
	foreach (map<string,any> value, values, ``{
	    symbol type = value["widget"]:`TextEntry;
	    any v = value["value"]:nil;
	    any id = value["id"]:nil;
	    boolean enabled = value["enabled"]:true;
	    if (id != nil)
	    {
		id = `id (id);
		symbol property = value_property [type]:`Value;
		
		UI::ChangeWidget ((term)id, property, v);
		UI::ChangeWidget ((term)id, `Enabled, enabled);
	    }
	});
    }

// functions

    void SwitchTo (map<string, any> descr, string tab)
    {
	y2milestone ("Switching to: %1", tab );
	// switch tab if needed
	if ( tab != current_tab )
	{
	    string  old_tab = current_tab;
		
	    // first, store the data from widgets
	    list<map<string, any> > values = TraverseAndStoreValues ( tabs[current_tab, "widget"]:`Empty (), []);
	    contents_cache[current_tab] = values;
		
	    // now, change the widget
	    current_tab = tab;
	    WidgetRedraw (descr);
				
	    // restore the data into widgets
	    	
	    if ( ! haskey (contents_cache, current_tab) )
	    {
		// call "init" for the widget
		CWM::initWidgets ([ tabs[current_tab]:$[] ]);

		if (lazy_switch_tab != nil)
		{
		    string temp = lazy_switch_tab;
		    lazy_switch_tab = nil;
		    SwitchTo (descr, temp);
		    return;
		}
	    }
	    else
	    {
		RestoreValues (contents_cache[current_tab]:[]);
	    }
	    // update the button to indicate the current one
	    if (! has_fancy_gui && old_tab != nil)
	    {
		UI::ChangeWidget ( `id (old_tab), `Label, tabs[old_tab,"header"]: "Tab" );
		UI::ChangeWidget ( `id (current_tab), `Label, UI::Glyph (`BulletArrowRight) + "  " + tabs[current_tab,"header"]: "Tab" );
	    }
	    else if ( has_fancy_gui )
	    {
	        UI::ChangeWidget (`id (`tab), `CurrentItem, current_tab);
	    }
	}
    }
    
    /**
      * Initialize the displayed table
      * @param descr map description map of the whole table
      * @param key tab widget key
      */
    global define void Init (map<string, any> descr, any key) ``{
	current_tab = descr["start_tab"]:"";
	contents_cache = $[];
	WidgetRedraw (descr);
	
	if (current_tab != nil)
	{
	    // initialize the widget
	    CWM::initWidgets ([ tabs[current_tab]:$[] ]);
	    
	    if (lazy_switch_tab != nil)
	    {
		SwitchTo (descr, lazy_switch_tab);
		lazy_switch_tab = nil;
		return;
	    }

	    if (! has_fancy_gui)
	    {
		UI::ChangeWidget ( `id (current_tab), `Label, UI::Glyph (`BulletArrowRight) + "  " + tabs[current_tab,"header"]: "Tab" );
	    }
	}
    }

    /**
      * Handle the event that happened on the widget
      * @param descr map description of the widget
      * @param key tab widget key
      * @param event_descr map event to handle
      * @return symbol modified event if needed
      */
    global define symbol Handle (map<string, any> descr, any key, map event_descr) ``{
	any event_id = event_descr["ID"]:nil;
	
	if ( is( event_id, string) && contains (ids, (string)event_id) )
	{
	    SwitchTo ( descr, (string)event_id );
	}
	else
	{
	    symbol ret = CWM::handleWidgets ( [ tabs[current_tab]:$[] ], event_descr );
	    if (lazy_switch_tab != nil)
	    {
		SwitchTo (descr, lazy_switch_tab);
		lazy_switch_tab = nil;
	    }
	    return ret;
	}
	return nil;
    }
    
    global void Store (string key, map event)
    {
	// first, store the data from widgets
	list<map<string, any> > values = TraverseAndStoreValues ( tabs[current_tab, "widget"]:`Empty (), []);
	contents_cache[current_tab] = values;

	// store all tabs, one by one
	foreach (string id, map<string,any> tab, tabs, ``{
	    if ( haskey (contents_cache, id) )
	    {
		// now, change the widget
		current_tab = id;
		WidgetRedraw ($[]);
				
		// restore the data into widgets
		RestoreValues (contents_cache[current_tab]:[]);
		CWM::saveWidgets ( [tab], event );
	    }
	});
    }

    /**
      * Wrapper for Init using CWM::GetProcessedWidget () for getting
      * widget description map
      * @param key any widget key
      */
    global define void InitWrapper (string key) ``{
	Init (CWM::GetProcessedWidget (), key);
    }

    /**
      * Wrapper for Handle using CWM::GetProcessedWidget () for getting
      * widget description map
      * @param key any widget key
      * @param event_descr map event description map
      * @return symbol return value for wizard sequencer or nil
      */
    global define symbol HandleWrapper (string key, map event_descr) ``{
	return Handle(CWM::GetProcessedWidget (), key, event_descr);
    }

    /**
      * Get the map with the table widget
      * @param attrib map table attributes
      * @param widget_descr map widget description map of the table, will be
      *  unioned with the generated map
      * @return map table widget
      */
    global define map CreateTabWidgetDescr (map attrib, map widget_descr) ``{
	// build the tabs
	ids = [];
	tabs = $[];
	
	term widget = nil;
	
	foreach (map tab, widget_descr["tabs"]:[], ``{
	    ids = add ( ids, "__" + tab["id"]:"" );
	    tabs[ "__" + tab["id"]:"" ] = (map<string,any>)tab;
	});
	
	has_fancy_gui = UI::HasSpecialWidget (`DumbTab);

	// widget
	if (has_fancy_gui)
	{
	    list<term> panes = [];
	    foreach (map tab, widget_descr["tabs"]:[], ``{
		panes = add ( panes, `item( `id( "__" + tab["id"]:"" ), tab["header"]: "Tab",
		    // current tab item is beeing selected, each header tab item has true/false
		    (widget_descr["start_tab"]:"" == tab["id"]:"")
		) );
	    });

	    term contents = `ReplacePoint(`id(`_tab_contents), `VSpacing (0) );
	    
	    widget = `DumbTab (`id (`tab), panes, contents);
	}
	else
	{
	    term tabbar = `HBox ();
	    foreach (map tab, widget_descr["tabs"]:[], ``{
		tabbar = add ( tabbar, `PushButton( `id( "__" + tab["id"]:"" ), tab["header"]: "Tab" ) );
	    });
	    
	    widget = (`VBox (`Left(tabbar), `Frame( "", `ReplacePoint (`id(`_tab_contents),`VSpacing(0)))));
	}
	
	if (haskey( widget_descr, "start_tab") )
	{
	    widget_descr["start_tab"] = "__" + widget_descr["start_tab"]:"";
	}
	else
	{
	    widget_descr["start_tab"] = ids[0]:nil;
	}
	
	# FIXME: process subwidgets!!!
    
	map ret = union ($[
            "custom_widget" : widget,
	    "_cwm_attrib" : attrib,
	    "widget" : `custom,
	    "help" : "",
	], widget_descr);

	if (! haskey (ret, "init"))
	{
	    ret["init"] = TabWidget::InitWrapper;
	}
	if (! haskey (ret, "handle"))
	{
	    ret["handle"] = TabWidget::HandleWrapper;
	}
	if (! haskey (ret, "store"))
	{
	    ret["store"] = TabWidget::Store;
	}

	return ret;
    }
    
    global boolean Modified () {
	// TODO: improve this
	return true;
    }
}
